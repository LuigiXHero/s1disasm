00000000                            ; ===========================================================================
00000000                            ;  DZ80 V3.4.1 Z80 Disassembly of z80nodata.bin
00000000                            ;  2007/09/18 15:48
00000000                            ;
00000000                            ;  Sonic 1 Z80 Driver disassembly by Puto.
00000000                            ;  Disassembly fixed, improved and integrated into SVN by Flamewing.
00000000                            ;  Adapted to s1disasm by Aurora Fields
00000000                            ; ===========================================================================
00000000                            
00000000                            		opt	l.				; . is the local label symbol
00000000                            		opt	ae-				; automatic even's are disabled by default
00000000                            		opt	ws+				; allow statements to contain white-spaces
00000000                            		opt	w+				; print warnings
00000000                            		opt	m+				; do not expand macros - if enabled, this can break assembling
00000000                            
00000000                            		org	0				; z80 Align, handled by the build process
00000000                            		include	"Macros - More CPUs.asm"	; include language macros
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Change CPU
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            cpu:		macro
00000000                            		if strcmp("\1","z80")
00000000                            		pusho			; save previous options
00000000                            		cpu_mode:	= 1	; Z80
00000000                            		opt	an+		; 1234h style numbering
00000000                            		opt	ae-		; disable auto evens
00000000                            
00000000                            		else
00000000                            		if def(cpu_mode)
00000000                            		popo			; restore options
00000000                            		endc
00000000                            
00000000                            		cpu_mode:	= 0	; 68000 by default
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; AS compatibility
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            phase:		macros
00000000                            		obj \1
00000000                            
00000000                            dephase:	macros
00000000                            		objend
00000000                            
00000000                            listing:	macro
00000000                            		if strcmp("\1","on")
00000000                            		list
00000000                            		else
00000000                            		nolist
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            binclude:	macros
00000000                            		incbin	\_
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Z80 instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            getzreg:	macro		; convert register to numerical value
00000000                            		if strcmp("\1","a")
00000000                            		zreg: = 7
00000000                            		elseif strcmp("\1","b")
00000000                            		zreg: = 0
00000000                            		elseif strcmp("\1","c")
00000000                            		zreg: = 1
00000000                            		elseif strcmp("\1","d")
00000000                            		zreg: = 2
00000000                            		elseif strcmp("\1","e")
00000000                            		zreg: = 3
00000000                            		elseif strcmp("\1","h")
00000000                            		zreg: = 4
00000000                            		elseif strcmp("\1","l")
00000000                            		zreg: = 5
00000000                            		elseif strcmp("\1","(hl)")
00000000                            		zreg: = 6
00000000                            		else
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            getindex:	macro		; convert index register to register offset and value
00000000                            		if instr("\1","(ix")
00000000                            		ireg: = $dd
00000000                            		elseif instr("\1","(iy")
00000000                            		ireg: = $fd
00000000                            		else
00000000                            			fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000 =00000000                  ix: =		0		; allows (ix+n) to be parsed as n
00000000 =00000000                  iy: =		0
00000000                            
00000000                            adc:		macro
00000000                            		if strcmp("\1","hl")
00000000                            			if strcmp("\2","bc")
00000000                            			dc.w $ed4a
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed5a
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed6a
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed7a
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            			mexit
00000000                            		endc
00000000                            
00000000                            		; "adc a, x" or "adc x"
00000000                            		if narg=2 & strcmp("\1","a")
00000000                            			shift		; ignore a
00000000                            		endc
00000000                            
00000000                            		if (narg=1) | (narg=2)
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $88+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dd8c
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dd8d
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fd8c
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fd8d
00000000                            			elseif instr("\1","(i") ; adc (ix+n)
00000000                            				getindex \1
00000000                            				dc.b ireg, $8e, \1
00000000                            			else			; adc n
00000000                            			dc.b $ce, \1
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            bit:		macro
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $40+(\1*8)+zreg
00000000                            		elseif instr("\2","(i")		; bit n,(ix+n)
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, \2, $40+((\1)*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            call:		macro
00000000                            		if narg=1		; call n
00000000                            		dc.b $cd
00000000                            		elseif narg=2		; call x, n
00000000                            			if strcmp("\1","nz")
00000000                            			dc.b $c4
00000000                            			elseif strcmp("\1","z")
00000000                            			dc.b $cc
00000000                            			elseif strcmp("\1","nc")
00000000                            			dc.b $d4
00000000                            			elseif strcmp("\1","c")
00000000                            			dc.b $dc
00000000                            			elseif strcmp("\1","po")
00000000                            			dc.b $e4
00000000                            			elseif strcmp("\1","pe")
00000000                            			dc.b $ec
00000000                            			elseif strcmp("\1","p")
00000000                            			dc.b $f4
00000000                            			elseif strcmp("\1","m")
00000000                            			dc.b $fc
00000000                            			else
00000000                            				fail
00000000                            			endc
00000000                            
00000000                            			shift
00000000                            		else
00000000                            			fail
00000000                            		endc
00000000                            
00000000                            		dc.b (\1)&$ff, (\1)>>8
00000000                            		endm
00000000                            
00000000                            ccf:		macros
00000000                            		dc.b $3f
00000000                            
00000000                            
00000000                            cp:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $b8+zreg
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $ddbc
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $ddbd
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fdbc
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fdbd
00000000                            		elseif instr("\1","(i") ; cp (ix+n)
00000000                            			getindex \1
00000000                            			dc.b ireg, $be, \1
00000000                            		else			; cp n
00000000                            		dc.b $fe, \1
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            cpd:		macros
00000000                            		dc.w $eda9
00000000                            
00000000                            
00000000                            cpdr:		macros
00000000                            		dc.w $edb9
00000000                            
00000000                            
00000000                            cpi:		macros
00000000                            		dc.w $eda1
00000000                            
00000000                            
00000000                            cpir:		macros
00000000                            		dc.w $edb1
00000000                            
00000000                            
00000000                            cpl:		macros
00000000                            		dc.b $2f
00000000                            
00000000                            
00000000                            daa:		macros
00000000                            		dc.b $27
00000000                            
00000000                            
00000000                            dec:		macro
00000000                            		if instr("a b c d e h l ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $5+(zreg*8)
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $dd25
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $dd2d
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fd25
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fd2d
00000000                            		elseif strcmp("\1","bc")
00000000                            		dc.b $b
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $1b
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $2b
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dd2b
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fd2b
00000000                            		elseif strcmp("\1","sp")
00000000                            		dc.b $3b
00000000                            		elseif instr("\1","(i")		; dec (ix+n)
00000000                            			getindex \1
00000000                            			dc.b ireg, $35, \1
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            di:		macros
00000000                            		dc.b $f3
00000000                            
00000000                            
00000000                            djnz:		macros
00000000                            		dc.b $10, \1-*-2
00000000                            
00000000                            
00000000                            ei:		macros
00000000                            		dc.b $fb
00000000                            
00000000                            
00000000                            ex:		macro
00000000                            		if strcmp("\_","af,af")		; ex af,af'
00000000                            		dc.b 8
00000000                            		elseif strcmp("\_","(sp),hl")
00000000                            		dc.b $e3
00000000                            		elseif strcmp("\_","(sp),ix")
00000000                            		dc.w $dde3
00000000                            		elseif strcmp("\_","(sp),iy")
00000000                            		dc.w $fde3
00000000                            		elseif strcmp("\_","de,hl")
00000000                            		dc.b $eb
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            exx:		macros
00000000                            		dc.b $d9
00000000                            
00000000                            
00000000                            halt:		macros
00000000                            		dc.b $76
00000000                            
00000000                            
00000000                            im:		macro
00000000                            		if \1=0
00000000                            		dc.w $ed46
00000000                            		elseif \1=1
00000000                            		dc.w $ed56
00000000                            		elseif \1=2
00000000                            		dc.w $ed5e
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            in:		macro
00000000                            		if strcmp("\1","a")
00000000                            			if strcmp("\2","(c)")
00000000                            			dc.w $ed78
00000000                            			else		; in a,n
00000000                            			dc.b $db, \2
00000000                            			endc
00000000                            		elseif instr("b c d e h l ","\1\ ")&strcmp("\2","(c)")
00000000                            		getzreg	\1
00000000                            		dc.w $ed40+(zreg*8)
00000000                            		elseif strcmp("\1","(c)")
00000000                            		dc.w $ed70
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            inc:		macro
00000000                            		if instr("a b c d e h l ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $4+(zreg*8)
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $dd24
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $dd2c
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fd24
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fd2c
00000000                            		elseif strcmp("\1","bc")
00000000                            		dc.b $3
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $13
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $23
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dd23
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fd23
00000000                            		elseif strcmp("\1","sp")
00000000                            		dc.b $33
00000000                            		elseif instr("\1","(i") ; inc (ix+n)
00000000                            			getindex \1
00000000                            			dc.b ireg, $34, \1
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ind:		macros
00000000                            		dc.w $edaa
00000000                            
00000000                            
00000000                            indr:		macros
00000000                            		dc.w $edba
00000000                            
00000000                            
00000000                            ini:		macros
00000000                            		dc.w $eda2
00000000                            
00000000                            
00000000                            inir:		macros
00000000                            		dc.w $edb2
00000000                            
00000000                            
00000000                            jp:		macro
00000000                            		if strcmp("\1","(hl)")
00000000                            		dc.b $e9
00000000                            		elseif strcmp("\1","(ix)")
00000000                            		dc.w $dde9
00000000                            		elseif strcmp("\1","(iy)")
00000000                            		dc.w $fde9
00000000                            		else
00000000                            			if strcmp("\1","nz")
00000000                            			dc.b $c2
00000000                            			elseif strcmp("\1","z")
00000000                            			dc.b $ca
00000000                            			elseif strcmp("\1","nc")
00000000                            			dc.b $d2
00000000                            			elseif strcmp("\1","c")
00000000                            			dc.b $da
00000000                            			elseif strcmp("\1","po")
00000000                            			dc.b $e2
00000000                            			elseif strcmp("\1","pe")
00000000                            			dc.b $ea
00000000                            			elseif strcmp("\1","p")
00000000                            			dc.b $f2
00000000                            			elseif strcmp("\1","m")
00000000                            			dc.b $fa
00000000                            			else		; jp n
00000000                            			dc.b $c3
00000000                            			endc
00000000                            			if narg=2
00000000                            			shift
00000000                            			endc
00000000                            			dc.b (\1)&$ff, (\1)>>8
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            jr:		macro
00000000                            		if strcmp("\1","nz")
00000000                            		dc.b $20
00000000                            		elseif strcmp("\1","z")
00000000                            		dc.b $28
00000000                            		elseif strcmp("\1","nc")
00000000                            		dc.b $30
00000000                            		elseif strcmp("\1","c")
00000000                            		dc.b $38
00000000                            		else		; jr n
00000000                            		dc.b $18
00000000                            		endc
00000000                            		if narg=2
00000000                            		shift
00000000                            		endc
00000000                            		dc.b (\1)-*-1
00000000                            		;if (((\1)-*)>=-$80)&(((\1)-*)<=$7f)
00000000                            		;fail
00000000                            		;endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ld:		macro
00000000                            		if strcmp("\1","a")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $78+zreg
00000000                            			elseif strcmp("\2","i")
00000000                            			dc.w $ed57
00000000                            			elseif strcmp("\2","r")
00000000                            			dc.w $ed5f
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd7c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd7d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd7c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd7d
00000000                            			elseif strcmp("\2","(bc)")
00000000                            			dc.b $0a
00000000                            			elseif strcmp("\2","(de)")
00000000                            			dc.b $1a
00000000                            			elseif instr("\2","(i") ; ld a,(ix+n)
00000000                            				getindex \2
00000000                            				dc.b ireg, $7e, \2
00000000                            			else
00000000                            				tmp_len: = strlen("\2")
00000000                            				tmp_fc:	substr	1,1,"\2"
00000000                            				tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            				if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld a,(n)
00000000                            				dc.b $3a, (\2)&$ff, (\2)>>8
00000000                            				else			; ld a,n
00000000                            				dc.b $3e, \2
00000000                            				endc
00000000                            			endc
00000000                            		elseif strcmp("\1","b")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $40+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd44
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd45
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd44
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd45
00000000                            			elseif instr("\2","(i") ; ld b,(ix+n)
00000000                            				getindex \2
00000000                            				dc.b ireg, $46, \2
00000000                            			else			; ld b,n
00000000                            			dc.b $6, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","c")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $48+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd4c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd4d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd4c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd4d
00000000                            			elseif instr("\2","(i") ; ld c,(ix+n)
00000000                            				getindex \2
00000000                            				dc.b ireg, $4e, \2
00000000                            			else			; ld c,n
00000000                            			dc.b $e, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","d")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $50+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd54
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd55
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd54
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd55
00000000                            			elseif instr("\2","(i") ; ld d,(ix+n)
00000000                            				getindex \2
00000000                            				dc.b ireg, $56, \2
00000000                            			else			; ld d,n
00000000                            			dc.b $16, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","e")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $58+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd5c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd5d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd5c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd5d
00000000                            			elseif instr("\2","(i") ; ld e,(ix+n)
00000000                            				getindex \2
00000000                            				dc.b ireg, $5e, \2
00000000                            			else			; ld e,n
00000000                            			dc.b $1e, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","h")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $60+zreg
00000000                            			elseif instr("\2","(i") ; ld h,(ix+n)
00000000                            				getindex \2
00000000                            				dc.b ireg, $66, \2
00000000                            			else			; ld h,n
00000000                            			dc.b $26, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","l")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $68+zreg
00000000                            			elseif instr("\2","(i") ; ld l,(ix+n)
00000000                            				getindex \2
00000000                            				dc.b ireg, $6e, \2
00000000                            			else			; ld l,n
00000000                            			dc.b $2e, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","i")
00000000                            		dc.w $ed47
00000000                            		elseif strcmp("\1","r")
00000000                            		dc.w $ed4f
00000000                            		elseif strcmp("\1","ixh")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $dd60+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd64
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd65
00000000                            			else			; ld ixh,n
00000000                            			dc.b $dd, $26, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","ixl")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $dd68+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd6c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd6d
00000000                            			else			; ld ixl,n
00000000                            			dc.b $dd, $2e, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","iyh")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $fd60+zreg
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd64
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd65
00000000                            			else			; ld iyh,n
00000000                            			dc.b $fd, $26, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","iyl")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $fd68+zreg
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd6c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd6d
00000000                            			else			; ld iyl,n
00000000                            			dc.b $fd, $2e, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","bc")
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld bc,(n)
00000000                            			dc.b $ed, $4b, \2&$ff, \2>>8
00000000                            			else			; ld bc,n
00000000                            			dc.b $1, (\2)&$ff, (\2)>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","de")
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld de,(n)
00000000                            			dc.b $ed, $5b, \2&$ff, \2>>8
00000000                            			else			; ld de,n
00000000                            			dc.b $11, (\2)&$ff, (\2)>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","hl")
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld hl,(n)
00000000                            			dc.b $ed, $6b, \2&$ff, \2>>8
00000000                            			else			; ld hl,n
00000000                            			dc.b $21, (\2)&$ff, (\2)>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","sp")
00000000                            			if strcmp("\2","hl")
00000000                            			dc.b $f9
00000000                            			elseif strcmp("\2","ix")
00000000                            			dc.w $ddf9
00000000                            			elseif strcmp("\2","iy")
00000000                            			dc.w $fdf9
00000000                            			else
00000000                            				tmp_len: = strlen("\2")
00000000                            				tmp_fc:	substr	1,1,"\2"
00000000                            				tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            				if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld sp,(n)
00000000                            				dc.b $ed, $7b, \2&$ff, \2>>8
00000000                            				else			; ld sp,n
00000000                            				dc.b $31, (\2)&$ff, (\2)>>8
00000000                            				endc
00000000                            			endc
00000000                            		elseif strcmp("\1","ix")
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld ix,(n)
00000000                            			dc.b $dd, $2a, \2&$ff, \2>>8
00000000                            			else			; ld ix,n
00000000                            			dc.b $dd, $21, (\2)&$ff, (\2)>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","iy")
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld iy,(n)
00000000                            			dc.b $fd, $2a, \2&$ff, \2>>8
00000000                            			else			; ld iy,n
00000000                            			dc.b $fd, $21, (\2)&$ff, (\2)>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","(bc)")
00000000                            		dc.b 2
00000000                            		elseif strcmp("\1","(de)")
00000000                            		dc.b $12
00000000                            		elseif strcmp("\1","(hl)")
00000000                            			if instr("a b c d e h l ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $70+zreg
00000000                            			else			; ld (hl),n
00000000                            			dc.b $36, \2
00000000                            			endc
00000000                            		elseif instr("\1","(i")		; ld (ix+n),?
00000000                            			if instr("a b c d e h l ","\2\ ")
00000000                            				getzreg	\2
00000000                            				getindex \1
00000000                            				dc.b ireg, $70|zreg, \1
00000000                            			else			; ld (ix+n),n
00000000                            				getindex \1
00000000                            				dc.b ireg, $36, \1, \2
00000000                            			endc
00000000                            		else			; ld (n),?
00000000                            			if strcmp("\2","a")
00000000                            			dc.b $32
00000000                            			elseif strcmp("\2","bc")
00000000                            			dc.w $ed43
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed53
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed63
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed73
00000000                            			elseif strcmp("\2","ix")
00000000                            			dc.w $dd22
00000000                            			elseif strcmp("\2","iy")
00000000                            			dc.w $fd22
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            			dc.b \1&$ff, \1>>8
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ldd:		macros
00000000                            		dc.w $eda8
00000000                            
00000000                            
00000000                            lddr:		macros
00000000                            		dc.w $edb8
00000000                            
00000000                            
00000000                            ldi:		macros
00000000                            		dc.w $eda0
00000000                            
00000000                            
00000000                            ldir:		macros
00000000                            		dc.w $edb0
00000000                            
00000000                            
00000000                            otdr:		macros
00000000                            		dc.w $edbb
00000000                            
00000000                            
00000000                            otir:		macros
00000000                            		dc.w $edb3
00000000                            
00000000                            
00000000                            out:		macro
00000000                            		if strcmp("\1","(c)")&instr("a b c d e h l ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.w $ed41+(zreg*8)
00000000                            		elseif strcmp("\_","(c),0")
00000000                            		dc.w $ed71
00000000                            		elseif strcmp("\2","a")	; out n,a
00000000                            		dc.b $d3, \1
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            outd:		macros
00000000                            		dc.w $edab
00000000                            
00000000                            
00000000                            outi:		macros
00000000                            		dc.w $eda3
00000000                            
00000000                            
00000000                            pop:		macro
00000000                            		if strcmp("\1","bc")
00000000                            		dc.b $c1
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $d1
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $e1
00000000                            		elseif strcmp("\1","af")
00000000                            		dc.b $f1
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dde1
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fde1
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            push:		macro
00000000                            		if strcmp("\1","bc")
00000000                            		dc.b $c5
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $d5
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $e5
00000000                            		elseif strcmp("\1","af")
00000000                            		dc.b $f5
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $fde5
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fde5
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            res:		macro
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $80+(\1*8)+zreg
00000000                            		elseif instr("\2","(i") ; res n,(ix+n)
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, \2
00000000                            		dc.b $80+((\1)*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ret:		macro
00000000                            		if strcmp("\1","nz")
00000000                            		dc.b $c0
00000000                            		elseif strcmp("\1","z")
00000000                            		dc.b $c8
00000000                            		elseif strcmp("\1","nc")
00000000                            		dc.b $d0
00000000                            		elseif strcmp("\1","c")
00000000                            		dc.b $d8
00000000                            		elseif strcmp("\1","po")
00000000                            		dc.b $e0
00000000                            		elseif strcmp("\1","pe")
00000000                            		dc.b $e8
00000000                            		elseif strcmp("\1","p")
00000000                            		dc.b $f0
00000000                            		elseif strcmp("\1","m")
00000000                            		dc.b $f8
00000000                            		elseif strlen("\1")=0	; ret
00000000                            		dc.b $c9
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            reti:		macros
00000000                            		dc.w $ed4d
00000000                            
00000000                            
00000000                            retn:		macros
00000000                            		dc.w $ed45
00000000                            
00000000                            
00000000                            rl:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $10+zreg
00000000                            		elseif instr("\1","(i") ; rl (ix+n)
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, \1
00000000                            
00000000                            			if narg=2	; rl (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $10+zreg
00000000                            			else
00000000                            			dc.b $16
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rla:		macros
00000000                            		dc.b $17
00000000                            
00000000                            
00000000                            rlc:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, zreg
00000000                            		elseif instr("\1","(i") ; rlc (ix+n)
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, \1
00000000                            
00000000                            			if narg=2	; rlc (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b zreg
00000000                            			else
00000000                            			dc.b $6
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rlca:		macros
00000000                            		dc.b $7
00000000                            
00000000                            
00000000                            rld:		macros
00000000                            		dc.w $ed6f
00000000                            
00000000                            
00000000                            rr:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $18+zreg
00000000                            		elseif instr("\1","(i") ; rr (ix+n)
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, \1
00000000                            
00000000                            			if narg=2	; rr (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $18+zreg
00000000                            			else
00000000                            			dc.b $1e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rra:		macros
00000000                            		dc.b $1f
00000000                            
00000000                            
00000000                            rrc:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $8+zreg
00000000                            		elseif instr("\1","(i") ; rrc (ix+n)
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, \1
00000000                            
00000000                            			if narg=2	; rrc (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $8+zreg
00000000                            			else
00000000                            			dc.b $e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rrca:		macros
00000000                            		dc.b $f
00000000                            
00000000                            
00000000                            rrd:		macros
00000000                            		dc.w $ed67
00000000                            
00000000                            
00000000                            rst:		macros
00000000                            		dc.b $c7+(\1&$38)
00000000                            
00000000                            
00000000                            sbc:		macro
00000000                            		if strcmp("\1","a")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $98+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd9c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd9d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd9c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd9d
00000000                            			elseif instr("\2","(i") ; sbc a,(ix+n)
00000000                            				getindex \2
00000000                            				dc.b ireg, $9e, \2
00000000                            			else			; sbc a,n
00000000                            			dc.b $de, \2
00000000                            			endc
00000000                            		elseif strcmp("\1","hl")
00000000                            			if strcmp("\2","bc")
00000000                            			dc.w $ed42
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed52
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed62
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed72
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            scf:		macros
00000000                            		dc.b $37
00000000                            
00000000                            
00000000                            set:		macro
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $c0+(\1*8)+zreg
00000000                            		elseif instr("\2","(i") ; set n,(ix+n)
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, \2, $c0+((\1)*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sla:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $20+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, \1
00000000                            
00000000                            			if narg=2	; sla (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $20+zreg
00000000                            			else		; sla (ix+n)
00000000                            			dc.b $26
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sll:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $30+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, \1
00000000                            
00000000                            			if narg=2	; sll (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $30+zreg
00000000                            			else		; sll (ix+n)
00000000                            			dc.b $36
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sra:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $28+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, \1
00000000                            
00000000                            			if narg=2	; sra (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $28+zreg
00000000                            			else		; sra (ix+n)
00000000                            			dc.b $2e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            srl:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $38+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, \1
00000000                            
00000000                            			if narg=2	; srl (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $38+zreg
00000000                            			else		; srl (ix+n)
00000000                            			dc.b $3e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            xor:		macro
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $a8+zreg
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $ddac
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $ddad
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fdac
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fdad
00000000                            		elseif instr("\1","(i") ; xor (ix+n)
00000000                            			getindex \1
00000000                            			dc.b ireg, $ae, \1
00000000                            		else			; xor n
00000000                            		dc.b $ee, \1
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            db:		macros
00000000                            		dc.b \_
00000000                            
00000000                            
00000000                            dw:		macro
00000000                            		rept narg
00000000                            		dc.b (\1)&$ff, (\1)>>8
00000000                            		shift
00000000                            		endr
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mixed instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            add:		macro
00000000                            		if cpu_mode=1		; Z80
00000000                            			if strcmp("\1","hl")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.b $9
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.b $19
00000000                            				elseif strcmp("\2","hl")
00000000                            				dc.b $29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.b $39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            
00000000                            			elseif strcmp("\1","ix")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.w $dd09
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.w $dd19
00000000                            				elseif strcmp("\2","ix")
00000000                            				dc.w $dd29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.w $dd39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            
00000000                            			elseif strcmp("\1","iy")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.w $fd09
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.w $fd19
00000000                            				elseif strcmp("\2","iy")
00000000                            				dc.w $fd29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.w $fd39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            			endc
00000000                            
00000000                            			; "add a, x" or "add x"
00000000                            			if narg=2 & strcmp("\1","a")
00000000                            				shift		; ignore a
00000000                            			endc
00000000                            
00000000                            			if (narg=1) | (narg=2)
00000000                            				if instr("a b c d e h l (hl) ","\1\ ")
00000000                            				getzreg	\1
00000000                            				dc.b $80+zreg
00000000                            				elseif strcmp("\1","ixh")
00000000                            				dc.w $dd84
00000000                            				elseif strcmp("\1","ixl")
00000000                            				dc.w $dd85
00000000                            				elseif strcmp("\1","iyh")
00000000                            				dc.w $fd84
00000000                            				elseif strcmp("\1","iyl")
00000000                            				dc.w $fd85
00000000                            				elseif instr("\1","(i") ; add (ix+n)
00000000                            					getindex \1
00000000                            					dc.b ireg, $86, \1
00000000                            				else			; add n
00000000                            				dc.b $c6, \1
00000000                            				endc
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            		else			; 68k
00000000                            		axd.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            and:		macro
00000000                            		if cpu_mode=1		; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $a0+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dda4
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dda5
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fda4
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fda5
00000000                            			elseif instr("\1","(i") ; and (ix+n)
00000000                            				getindex \1
00000000                            				dc.b ireg, $a6, \1
00000000                            			else			; and n
00000000                            			dc.b $e6, \1
00000000                            			endc
00000000                            		else			; 68k
00000000                            		anx.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            neg:		macro
00000000                            		if cpu_mode=1		; Z80
00000000                            		dc.w $ed44
00000000                            		else			; 68k
00000000                            		nxg
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            nop:		macro
00000000                            		if cpu_mode=1		; Z80
00000000                            		dc.b 0
00000000                            		else			; 68k
00000000                            		nxp
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            or:		macro
00000000                            		if cpu_mode=1		; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $b0+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $ddb4
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $ddb5
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fdb4
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fdb5
00000000                            			elseif instr("\1","(i") ; or (ix+n)
00000000                            				getindex \1
00000000                            				dc.b ireg, $b6, \1
00000000                            			else			; or n
00000000                            			dc.b $f6, \1
00000000                            			endc
00000000                            		else			; 68k
00000000                            		ox.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sub:		macro
00000000                            		if cpu_mode=1		; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $90+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dd94
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dd95
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fd94
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fd95
00000000                            			elseif instr("\1","(i") ; sub (ix+n)
00000000                            				getindex \1
00000000                            				dc.b ireg, $96, \1
00000000                            			else			; sub n
00000000                            			dc.b $d6, \1
00000000                            			endc
00000000                            		else			; 68k
00000000                            		sxb.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Restored ASM68k instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            adda:		macros
00000000                            		axda.\0	\_
00000000                            
00000000                            addi:		macros
00000000                            		axdi.\0	\_
00000000                            
00000000                            addq:		macros
00000000                            		axdq.\0	\_
00000000                            
00000000                            addx:		macros
00000000                            		axdx.\0	\_
00000000                            
00000000                            andi:		macros
00000000                            		anxi.\0	\_
00000000                            
00000000                            negx:		macros
00000000                            		nxgx.\0	\_
00000000                            
00000000                            ori:		macros
00000000                            		oxi.\0	\_
00000000                            
00000000                            suba:		macros
00000000                            		sxba.\0	\_
00000000                            
00000000                            subi:		macros
00000000                            		sxbi.\0	\_
00000000                            
00000000                            subq:		macros
00000000                            		sxbq.\0	\_
00000000                            
00000000                            subx:		macros
00000000                            		sxbx.\0	\_
00000000                            		cpu	z80				; also start a new z80 program
00000000                          M 	pusho
00000000 =00000001                M 	cpu_mode:	= 1
00000000                          M 	opt	an+
00000000                          M 	opt	ae-
00000000                            
00000000 =DEADBEEF                  SEGAPCM		equ $DEADBEEF				; give Sega PCM an arbitary value. Basically, just avoid getting optimized by Kosinski
00000000 =0000AC1D                  SEGAPCM_Len	equ $AC1D				; give Sega PCM an arbitary size. Basically, just avoid getting optimized by Kosinski
00000000 =0000000B                  SEGAPCM_Pitch	equ 0Bh					; the pitch of the SEGA sound
00000000                            
00000000                            	rsset 1FFCh					; extra RAM variables
00000000 =00001FFC                  z80_stack	rs.b 1					; stack pointer
00000000 =00001FFD                  zDAC_Status	rs.b 1					; bit 7 set if the driver is not accepting new samples, it is clear otherwise
00000000                            		rs.b 1					; unused
00000000 =00001FFF                  zDAC_Sample	rs.b 1					; sample to play, the 68K will move into this locatiton whatever sample that's supposed to be played.
00000000                            
00000000 =00004000                  YMREG1		equ 4000h				; YM2612/YM2428 port 1 address register
00000000 =00006000                  zBankSelect	equ 6000h				; ROM bank shift register
00000000 =00008000                  zWindow		equ 8000h				; start of ROM window
00000000                            ; ===========================================================================
00000000                            
00000000                            Z80Driver_Start:
00000000                            		di					; Disable interrupts. Interrupts will never be reenabled
00000000 F3                       M 	dc.b	$f3
00000001                            		di					; for the z80, so that no code will be executed on V-Int.
00000001 F3                       M 	dc.b	$f3
00000002                            		di					; This means that the sample loop is all the z80 does.
00000002 F3                       M 	dc.b	$f3
00000003                            
00000003                            		ld	sp,z80_stack			; Initialize the stack pointer (unused throughout the driver)
00000003 =00000009                M 	tmp_len:	= strlen("z80_stack")
00000003                          M 	tmp_fc:	substr 1,1,"z80_stack"
00000003                          M 	tmp_lc:	substr tmp_len,tmp_len,"z80_stack"
00000003 31FC 1F                  M 	dc.b	$31,(z80_stack)&$ff,(z80_stack)>>8
00000006                            		ld	ix,YMREG1			; ix = Pointer to memory-mapped communication register with YM2612
00000006 =00000006                M 	tmp_len:	= strlen("ymreg1")
00000006                          M 	tmp_fc:	substr 1,1,"ymreg1"
00000006                          M 	tmp_lc:	substr tmp_len,tmp_len,"ymreg1"
00000006 DD21 0040                M 	dc.b	$dd,$21,(ymreg1)&$ff,(ymreg1)>>8
0000000A                            
0000000A                            		xor	a				; a=0
0000000A                          M 	getzreg	a
0000000A =00000007                M 	zreg:	= 7
0000000A AF                       M 	dc.b	$a8+zreg
0000000B                            		ld	(zDAC_Status),a			; Disable DAC
0000000B 32                       M 	dc.b	$32
0000000C FD1F                     M 	dc.b	(zdac_status)&$ff,(zdac_status)>>8
0000000E                            		ld	(zDAC_Sample),a			; Clear sample
0000000E 32                       M 	dc.b	$32
0000000F FF1F                     M 	dc.b	(zdac_sample)&$ff,(zdac_sample)>>8
00000011                            		ld	a,(SEGAPCM>>24)&$FF		; least significant bit from ROM bank ID
00000011 =00000011                M 	tmp_len:	= strlen("(segapcm>>24)&$ff")
00000011                          M 	tmp_fc:	substr 1,1,"(segapcm>>24)&$ff"
00000011                          M 	tmp_lc:	substr tmp_len,tmp_len,"(segapcm>>24)&$ff"
00000011 3EDE                     M 	dc.b	$3e,(segapcm>>24)&$ff
00000013                            		ld	(zBankSelect),a			; Latch it to bank register, initializing bank switch
00000013 32                       M 	dc.b	$32
00000014 0060                     M 	dc.b	(zbankselect)&$ff,(zbankselect)>>8
00000016                            
00000016                            		ld	b,8				; Number of bits to latch to ROM bank
00000016 0608                     M 	dc.b	$6,8
00000018                            		ld	a,(SEGAPCM>>16)&$FF		; Bank ID without the least significant bit
00000018 =00000011                M 	tmp_len:	= strlen("(segapcm>>16)&$ff")
00000018                          M 	tmp_fc:	substr 1,1,"(segapcm>>16)&$ff"
00000018                          M 	tmp_lc:	substr tmp_len,tmp_len,"(segapcm>>16)&$ff"
00000018 3EAD                     M 	dc.b	$3e,(segapcm>>16)&$ff
0000001A                            
0000001A                            .bankswitch
0000001A                            		ld	(zBankSelect),a			; Latch another bit to bank register.
0000001A 32                       M 	dc.b	$32
0000001B 0060                     M 	dc.b	(zbankselect)&$ff,(zbankselect)>>8
0000001D                            		rrca					; Move next bit into position
0000001D 0F                       M 	dc.b	$f
0000001E                            		djnz	.bankswitch			; decrement and loop if not zero
0000001E 10FA                     M 	dc.b	$10,.bankswitch-*-2
00000020                            		jr	CheckForSamples
00000020 18                       M 	dc.b	$18
00000021 00                       M 	dc.b	(checkforsamples)-*-1
00000022                            
00000022                            ; ===========================================================================
00000022                            ; ---------------------------------------------------------------------------
00000022                            ; DAC decode look-up table
00000022                            ; ---------------------------------------------------------------------------
00000022                            
00000022                            zDACDecodeTbl:
00000022                            	db   0,	  1,   2,   4,   8,  10h,  20h,  40h
00000022 0001 0204 0810 2040      M 	dc.b	0,1,2,4,8,10h,20h,40h
0000002A                            	db 80h,	 -1,  -2,  -4,  -8, -10h, -20h, -40h
0000002A 80FF FEFC F8F0 E0C0      M 	dc.b	80h,-1,-2,-4,-8,-10h,-20h,-40h
00000032                            
00000032                            ; ---------------------------------------------------------------------------
00000032                            
00000032                            CheckForSamples:
00000032                            		ld	hl,zDAC_Sample			; Load the address of next sample.
00000032 =0000000B                M 	tmp_len:	= strlen("zdac_sample")
00000032                          M 	tmp_fc:	substr 1,1,"zdac_sample"
00000032                          M 	tmp_lc:	substr tmp_len,tmp_len,"zdac_sample"
00000032 21FF 1F                  M 	dc.b	$21,(zdac_sample)&$ff,(zdac_sample)>>8
00000035                            
00000035                            @nullsample
00000035                            		ld	a,(hl)				; a = next sample to play.
00000035                          M 	getzreg	(hl)
00000035 =00000006                M 	zreg:	= 6
00000035 7E                       M 	dc.b	$78+zreg
00000036                            		or	a				; Do we have a valid sample?
00000036                          M 	getzreg	a
00000036 =00000007                M 	zreg:	= 7
00000036 B7                       M 	dc.b	$b0+zreg
00000037                            		jp	p,@nullsample			; Loop until we do
00000037 F2                       M 	dc.b	$f2
00000038                          M 	shift
00000038 3500                     M 	dc.b	(@nullsample)&$ff,(@nullsample)>>8
0000003A                            
0000003A                            		sub	81h				; Make 0-based index
0000003A D681                     M 	dc.b	$d6,81h
0000003C                            		ld	(hl),a				; Store it back into sample index (i.e., mark it as being played)
0000003C                          M 	getzreg	a
0000003C =00000007                M 	zreg:	= 7
0000003C 77                       M 	dc.b	$70+zreg
0000003D                            		cp	6				; Is the sample 87h or higher?
0000003D FE06                     M 	dc.b	$fe,6
0000003F                            		jr	nc,Play_Sega			; If yes, branch
0000003F 30                       M 	dc.b	$30
00000040                          M 	shift
00000040 00                       M 	dc.b	(play_sega)-*-1
00000041                            
00000041                            		ld	de,0				; de = 0
00000041 =00000001                M 	tmp_len:	= strlen("0")
00000041                          M 	tmp_fc:	substr 1,1,"0"
00000041                          M 	tmp_lc:	substr tmp_len,tmp_len,"0"
00000041 1100 00                  M 	dc.b	$11,(0)&$ff,(0)>>8
00000044                            		ld	iy,PCM_Table			; iy = pointer to PCM Table
00000044 =00000009                M 	tmp_len:	= strlen("pcm_table")
00000044                          M 	tmp_fc:	substr 1,1,"pcm_table"
00000044                          M 	tmp_lc:	substr tmp_len,tmp_len,"pcm_table"
00000044 FD21 0000                M 	dc.b	$fd,$21,(pcm_table)&$ff,(pcm_table)>>8
00000048                            
00000048                            		sla	a				; each PCM entry has 8 bytes of data
00000048                          M 	getzreg	a
00000048 =00000007                M 	zreg:	= 7
00000048 CB27                     M 	dc.b	$cb,$20+zreg
0000004A                            		sla	a				; this code shifts a left by 3
0000004A                          M 	getzreg	a
0000004A =00000007                M 	zreg:	= 7
0000004A CB27                     M 	dc.b	$cb,$20+zreg
0000004C                            		sla	a				; which is the same as multiplying sample ID by 8.
0000004C                          M 	getzreg	a
0000004C =00000007                M 	zreg:	= 7
0000004C CB27                     M 	dc.b	$cb,$20+zreg
0000004E                            
0000004E                            		ld	b,0				;
0000004E 0600                     M 	dc.b	$6,0
00000050                            		ld	c,a				; bc = offset into PCM_Table for the sample data
00000050                          M 	getzreg	a
00000050 =00000007                M 	zreg:	= 7
00000050 4F                       M 	dc.b	$48+zreg
00000051                            		add	iy,bc				; iy = pointer to DAC sample entry
00000051 FD09                     M 	dc.w	$fd09
00000053                          M 	mexit
00000053                            
00000053                            		ld	e,(iy+0)			;
00000053                          M 	getindex	(iy+0)
00000053 =000000FD                M 	ireg:	= $fd
00000053 FD5E 00                  M 	dc.b	ireg,$5e,(iy+0)
00000056                            		ld	d,(iy+1)			; de = pointer to the DAC sample
00000056                          M 	getindex	(iy+1)
00000056 =000000FD                M 	ireg:	= $fd
00000056 FD56 01                  M 	dc.b	ireg,$56,(iy+1)
00000059                            		ld	c,(iy+2)			;
00000059                          M 	getindex	(iy+2)
00000059 =000000FD                M 	ireg:	= $fd
00000059 FD4E 02                  M 	dc.b	ireg,$4e,(iy+2)
0000005C                            		ld	b,(iy+3)			; bc = size of the DAC sample
0000005C                          M 	getindex	(iy+3)
0000005C =000000FD                M 	ireg:	= $fd
0000005C FD46 03                  M 	dc.b	ireg,$46,(iy+3)
0000005F                            		exx					; bc' = size of sample, de' = location of sample, hl' = pointer to zDAC_Sample
0000005F D9                       M 	dc.b	$d9
00000060                            
00000060                            		ld	d,80h				; initialize the DPCM accumulator as 80h
00000060 1680                     M 	dc.b	$16,80h
00000062                            		ld	hl,zDAC_Status			; hl = pointer to zDAC_Status
00000062 =0000000B                M 	tmp_len:	= strlen("zdac_status")
00000062                          M 	tmp_fc:	substr 1,1,"zdac_status"
00000062                          M 	tmp_lc:	substr tmp_len,tmp_len,"zdac_status"
00000062 21FD 1F                  M 	dc.b	$21,(zdac_status)&$ff,(zdac_status)>>8
00000065                            		ld	(hl),d				; Set flag to not accept driver input
00000065                          M 	getzreg	d
00000065 =00000002                M 	zreg:	= 2
00000065 72                       M 	dc.b	$70+zreg
00000066                            
00000066                            		ld	(ix+0),2Bh			; Select enable/disable DAC register
00000066                          M 	getindex	(ix+0)
00000066 =000000DD                M 	ireg:	= $dd
00000066 DD36 002B                M 	dc.b	ireg,$36,(ix+0),2bh
0000006A                            		ld	e,2Ah				; prepare DAC data register into e
0000006A 1E2A                     M 	dc.b	$1e,2ah
0000006C                            		ld	c,(iy+4)			; c = pitch of the DAC sample
0000006C                          M 	getindex	(iy+4)
0000006C =000000FD                M 	ireg:	= $fd
0000006C FD4E 04                  M 	dc.b	ireg,$4e,(iy+4)
0000006F                            
0000006F                            		ld	(ix+1),d			; Enable DAC
0000006F                          M 	getzreg	d
0000006F =00000002                M 	zreg:	= 2
0000006F                          M 	getindex	(ix+1)
0000006F =000000DD                M 	ireg:	= $dd
0000006F DD72 01                  M 	dc.b	ireg,$70|zreg,(ix+1)
00000072                            		ld	(hl),0				; Set flag to accept driver input
00000072 3600                     M 	dc.b	$36,0
00000074                            
00000074                            		exx					; swap registers
00000074 D9                       M 	dc.b	$d9
00000075                            		ld	h,(zDACDecodeTbl&0FF00h)>>8	; load upper byte of zDACDecodeTbl into h (l will be loaded dynamically)
00000075 2600                     M 	dc.b	$26,(zdacdecodetbl&0ff00h)>>8
00000077                            
00000077                            ; ===========================================================================
00000077                            ; ---------------------------------------------------------------------------
00000077                            ; DPCM playback loop
00000077                            ;
00000077                            ; registers:
00000077                            ; 	bc: number of bytes left to play
00000077                            ;	de: pointer to the next byte to play
00000077                            ;	hl: zDAC_Sample
00000077                            ;	b': will be used for delay loops
00000077                            ;	c': sample pitch (copied to b')
00000077                            ;	d': DPCM accumulator
00000077                            ;	e': DAC data register value (2Ah)
00000077                            ;	hl': zDAC_Status
00000077                            ; ---------------------------------------------------------------------------
00000077                            
00000077                            PlaySampleLoop:
00000077                            		ld	a,(de)				; load the current DPCM byte into a
00000077 1A                       M 	dc.b	$1a
00000078                            		and	0F0h				; get upper nibble
00000078 E6F0                     M 	dc.b	$e6,0f0h
0000007A                            
0000007A                            		rrca					; we need to shift upper nibble to lower nibble
0000007A 0F                       M 	dc.b	$f
0000007B                            		rrca					; the code below uses this to load the look-up table value
0000007B 0F                       M 	dc.b	$f
0000007C                            		rrca					; to process the next DPCM byte
0000007C 0F                       M 	dc.b	$f
0000007D                            		rrca					; so we shift right by 4 bits
0000007D 0F                       M 	dc.b	$f
0000007E                            
0000007E                            		add	a,zDACDecodeTbl&0FFh		; add the lower byte of zDACDecodeTbl into a
0000007E                          M 	shift
0000007E C622                     M 	dc.b	$c6,zdacdecodetbl&0ffh
00000080                            		ld	l,a				; hl = the specific byte we want to read within zDACDecodeTbl
00000080                          M 	getzreg	a
00000080 =00000007                M 	zreg:	= 7
00000080 6F                       M 	dc.b	$68+zreg
00000081                            		ld	a,(hl)				; a = the accumulator offset value
00000081                          M 	getzreg	(hl)
00000081 =00000006                M 	zreg:	= 6
00000081 7E                       M 	dc.b	$78+zreg
00000082                            
00000082                            		exx					; swap registers
00000082 D9                       M 	dc.b	$d9
00000083                            		add	a,d				;
00000083                          M 	shift
00000083                          M 	getzreg	d
00000083 =00000002                M 	zreg:	= 2
00000083 82                       M 	dc.b	$80+zreg
00000084                            		ld	d,a				; add a into the accumulator
00000084                          M 	getzreg	a
00000084 =00000007                M 	zreg:	= 7
00000084 57                       M 	dc.b	$50+zreg
00000085                            
00000085                            		ld	(hl),l				; Set flag to not accept driver input (l = FFh)
00000085                          M 	getzreg	l
00000085 =00000005                M 	zreg:	= 5
00000085 75                       M 	dc.b	$70+zreg
00000086                            		ld	(ix+0),e			; select the DAC data register (2Ah)
00000086                          M 	getzreg	e
00000086 =00000003                M 	zreg:	= 3
00000086                          M 	getindex	(ix+0)
00000086 =000000DD                M 	ireg:	= $dd
00000086 DD73 00                  M 	dc.b	ireg,$70|zreg,(ix+0)
00000089                            		ld	(ix+1),d			; send DAC value to YM
00000089                          M 	getzreg	d
00000089 =00000002                M 	zreg:	= 2
00000089                          M 	getindex	(ix+1)
00000089 =000000DD                M 	ireg:	= $dd
00000089 DD72 01                  M 	dc.b	ireg,$70|zreg,(ix+1)
0000008C                            		ld	(hl),h				; Set flag to accept driver input (h = 1Fh)
0000008C                          M 	getzreg	h
0000008C =00000004                M 	zreg:	= 4
0000008C 74                       M 	dc.b	$70+zreg
0000008D                            
0000008D                            		ld	b,c				; b = sample pitch
0000008D                          M 	getzreg	c
0000008D =00000001                M 	zreg:	= 1
0000008D 41                       M 	dc.b	$40+zreg
0000008E                            		djnz	*				; delay the z80 to allow for pitch variations
0000008E 10FE                     M 	dc.b	$10,*-*-2
00000090                            ; ---------------------------------------------------------------------------
00000090                            
00000090                            		exx
00000090 D9                       M 	dc.b	$d9
00000091                            		ld	a,(de)				; load the current DPCM byte into a
00000091 1A                       M 	dc.b	$1a
00000092                            		and	0Fh				; get lower nibble
00000092 E60F                     M 	dc.b	$e6,0fh
00000094                            
00000094                            		add	a,zDACDecodeTbl&0FFh		; add the lower byte of zDACDecodeTbl into a
00000094                          M 	shift
00000094 C622                     M 	dc.b	$c6,zdacdecodetbl&0ffh
00000096                            		ld	l,a				; hl = the specific byte we want to read within zDACDecodeTbl
00000096                          M 	getzreg	a
00000096 =00000007                M 	zreg:	= 7
00000096 6F                       M 	dc.b	$68+zreg
00000097                            		ld	a,(hl)				; a = the accumulator offset value
00000097                          M 	getzreg	(hl)
00000097 =00000006                M 	zreg:	= 6
00000097 7E                       M 	dc.b	$78+zreg
00000098                            
00000098                            		exx					; swap registers
00000098 D9                       M 	dc.b	$d9
00000099                            		add	a,d				;
00000099                          M 	shift
00000099                          M 	getzreg	d
00000099 =00000002                M 	zreg:	= 2
00000099 82                       M 	dc.b	$80+zreg
0000009A                            		ld	d,a				; add a into the accumulator
0000009A                          M 	getzreg	a
0000009A =00000007                M 	zreg:	= 7
0000009A 57                       M 	dc.b	$50+zreg
0000009B                            
0000009B                            		ld	(hl),l				; Set flag to not accept driver input (l = FFh)
0000009B                          M 	getzreg	l
0000009B =00000005                M 	zreg:	= 5
0000009B 75                       M 	dc.b	$70+zreg
0000009C                            		ld	(ix+0),e			; select the DAC data register (2Ah)
0000009C                          M 	getzreg	e
0000009C =00000003                M 	zreg:	= 3
0000009C                          M 	getindex	(ix+0)
0000009C =000000DD                M 	ireg:	= $dd
0000009C DD73 00                  M 	dc.b	ireg,$70|zreg,(ix+0)
0000009F                            		ld	(ix+1),d			; send DAC value to YM
0000009F                          M 	getzreg	d
0000009F =00000002                M 	zreg:	= 2
0000009F                          M 	getindex	(ix+1)
0000009F =000000DD                M 	ireg:	= $dd
0000009F DD72 01                  M 	dc.b	ireg,$70|zreg,(ix+1)
000000A2                            		ld	(hl),h				; Set flag to accept driver input (h = 1Fh)
000000A2                          M 	getzreg	h
000000A2 =00000004                M 	zreg:	= 4
000000A2 74                       M 	dc.b	$70+zreg
000000A3                            
000000A3                            		ld	b,c				; b = sample pitch
000000A3                          M 	getzreg	c
000000A3 =00000001                M 	zreg:	= 1
000000A3 41                       M 	dc.b	$40+zreg
000000A4                            		djnz	*				; delay the z80 to allow for pitch variations
000000A4 10FE                     M 	dc.b	$10,*-*-2
000000A6                            ; ---------------------------------------------------------------------------
000000A6                            
000000A6                            		exx					; swap registers
000000A6 D9                       M 	dc.b	$d9
000000A7                            		ld	a,(zDAC_Sample)			; load the current sample number (could have used hl?)
000000A7 =0000000D                M 	tmp_len:	= strlen("(zdac_sample)")
000000A7                          M 	tmp_fc:	substr 1,1,"(zdac_sample)"
000000A7                          M 	tmp_lc:	substr tmp_len,tmp_len,"(zdac_sample)"
000000A7 3AFF 1F                  M 	dc.b	$3a,((zdac_sample))&$ff,((zdac_sample))>>8
000000AA                            		bit	7,a				; check if bit7 was set (this indicates that a new sample was loaded)
000000AA                          M 	getzreg	a
000000AA =00000007                M 	zreg:	= 7
000000AA CB7F                     M 	dc.b	$cb,$40+(7*8)+zreg
000000AC                            		jp	nz,CheckForSamples		; if set, load the next sample
000000AC C2                       M 	dc.b	$c2
000000AD                          M 	shift
000000AD 3200                     M 	dc.b	(checkforsamples)&$ff,(checkforsamples)>>8
000000AF                            
000000AF                            		inc	de				; go to the next byte in the sample
000000AF 13                       M 	dc.b	$13
000000B0                            		dec	bc				; decrement the number of bytes left to play
000000B0 0B                       M 	dc.b	$b
000000B1                            
000000B1                            		ld	a,c				; check if bc is 0
000000B1                          M 	getzreg	c
000000B1 =00000001                M 	zreg:	= 1
000000B1 79                       M 	dc.b	$78+zreg
000000B2                            		or	b				; this does the actual check - if not, then a will be nonzero
000000B2                          M 	getzreg	b
000000B2 =00000000                M 	zreg:	= 0
000000B2 B0                       M 	dc.b	$b0+zreg
000000B3                            		jp	nz,PlaySampleLoop		; if bc is not 0, keep playing the sample
000000B3 C2                       M 	dc.b	$c2
000000B4                          M 	shift
000000B4 7700                     M 	dc.b	(playsampleloop)&$ff,(playsampleloop)>>8
000000B6                            		jp	CheckForSamples			; Sample is done; wait for new samples
000000B6 C3                       M 	dc.b	$c3
000000B7 3200                     M 	dc.b	(checkforsamples)&$ff,(checkforsamples)>>8
000000B9                            
000000B9                            ; ===========================================================================
000000B9                            ; ---------------------------------------------------------------------------
000000B9                            ; Subroutine to play the SEGA PCM
000000B9                            ; ---------------------------------------------------------------------------
000000B9                            
000000B9                            Play_Sega:
000000B9                            		ld	de,SEGAPCM&$FFFF		; de = bank-relative location of the SEGA sound
000000B9 =0000000D                M 	tmp_len:	= strlen("segapcm&$ffff")
000000B9                          M 	tmp_fc:	substr 1,1,"segapcm&$ffff"
000000B9                          M 	tmp_lc:	substr tmp_len,tmp_len,"segapcm&$ffff"
000000B9 11EF BE                  M 	dc.b	$11,(segapcm&$ffff)&$ff,(segapcm&$ffff)>>8
000000BC                            		ld	hl,SEGAPCM_Len&$FFFF		; hl = size of the SEGA sound
000000BC =00000011                M 	tmp_len:	= strlen("segapcm_len&$ffff")
000000BC                          M 	tmp_fc:	substr 1,1,"segapcm_len&$ffff"
000000BC                          M 	tmp_lc:	substr tmp_len,tmp_len,"segapcm_len&$ffff"
000000BC 211D AC                  M 	dc.b	$21,(segapcm_len&$ffff)&$ff,(segapcm_len&$ffff)>>8
000000BF                            		ld	c,2Ah				; c = DAC data register
000000BF 0E2A                     M 	dc.b	$e,2ah
000000C1                            
000000C1                            .play
000000C1                            		ld	a,(de)				; a = next byte of the SEGA PCM
000000C1 1A                       M 	dc.b	$1a
000000C2                            		ld	(ix+0),c			; select the DAC data register (2Ah)
000000C2                          M 	getzreg	c
000000C2 =00000001                M 	zreg:	= 1
000000C2                          M 	getindex	(ix+0)
000000C2 =000000DD                M 	ireg:	= $dd
000000C2 DD71 00                  M 	dc.b	ireg,$70|zreg,(ix+0)
000000C5                            		ld	(ix+1),a			; send DAC value to YM
000000C5                          M 	getzreg	a
000000C5 =00000007                M 	zreg:	= 7
000000C5                          M 	getindex	(ix+1)
000000C5 =000000DD                M 	ireg:	= $dd
000000C5 DD77 01                  M 	dc.b	ireg,$70|zreg,(ix+1)
000000C8                            
000000C8                            		ld	b,SEGAPCM_Pitch			; b = pitch of the SEGA sample
000000C8 060B                     M 	dc.b	$6,segapcm_pitch
000000CA                            		djnz	*				; delay the z80 to allow for pitch variations
000000CA 10FE                     M 	dc.b	$10,*-*-2
000000CC                            
000000CC                            		inc	de				; go to the next byte in the sample
000000CC 13                       M 	dc.b	$13
000000CD                            		dec	hl				; decrement the number of bytes left to play
000000CD 2B                       M 	dc.b	$2b
000000CE                            
000000CE                            		ld	a,l				; check if hl is 0
000000CE                          M 	getzreg	l
000000CE =00000005                M 	zreg:	= 5
000000CE 7D                       M 	dc.b	$78+zreg
000000CF                            		or	h				; this does the actual check - if not, then a will be nonzero
000000CF                          M 	getzreg	h
000000CF =00000004                M 	zreg:	= 4
000000CF B4                       M 	dc.b	$b0+zreg
000000D0                            		jp	nz,.play			; if hl is not 0, keep playing the sample
000000D0 C2                       M 	dc.b	$c2
000000D1                          M 	shift
000000D1 C100                     M 	dc.b	(.play)&$ff,(.play)>>8
000000D3                            		jp	CheckForSamples			; SEGA sound is done; wait for new samples
000000D3 C3                       M 	dc.b	$c3
000000D4 3200                     M 	dc.b	(checkforsamples)&$ff,(checkforsamples)>>8
000000D6                            
000000D6                            ; ===========================================================================
000000D6                            ; ---------------------------------------------------------------------------
000000D6                            ; Table referencing the three PCM samples
000000D6                            ;
000000D6                            ; As documented by jman2050, first two bytes are a pointer to the sample,
000000D6                            ; third and fourth are the sample size, fifth is the pitch, 6-8 are unused.
000000D6                            ; ---------------------------------------------------------------------------
000000D6                            
000000D6                            zsample		macro	name, pitch
000000D6                            	dw \name
000000D6                            	dw \name\_End-\name
000000D6                            	dw \pitch
000000D6                            	dw 0000h
000000D6                            	endm
000000D6                            
000000D6                            PCM_Table:
000000D6                            		zsample	dKick, 17h			; Kick sample
000000D6                          M 	dw	dkick
000000D6                          M 	rept	narg
000000D6 0000                     M 	dc.b	(dkick)&$ff,(dkick)>>8
000000D8                          M 	shift
000000D8                          M 	dw	dkick_end-dkick
000000D8                          M 	rept	narg
000000D8 0000                     M 	dc.b	(dkick_end-dkick)&$ff,(dkick_end-dkick)>>8
000000DA                          M 	shift
000000DA                          M 	dw	17h
000000DA                          M 	rept	narg
000000DA 1700                     M 	dc.b	(17h)&$ff,(17h)>>8
000000DC                          M 	shift
000000DC                          M 	dw	0000h
000000DC                          M 	rept	narg
000000DC 0000                     M 	dc.b	(0000h)&$ff,(0000h)>>8
000000DE                          M 	shift
000000DE                            		zsample	dSnare, 1h			; Snare sample
000000DE                          M 	dw	dsnare
000000DE                          M 	rept	narg
000000DE 0000                     M 	dc.b	(dsnare)&$ff,(dsnare)>>8
000000E0                          M 	shift
000000E0                          M 	dw	dsnare_end-dsnare
000000E0                          M 	rept	narg
000000E0 0000                     M 	dc.b	(dsnare_end-dsnare)&$ff,(dsnare_end-dsnare)>>8
000000E2                          M 	shift
000000E2                          M 	dw	1h
000000E2                          M 	rept	narg
000000E2 0100                     M 	dc.b	(1h)&$ff,(1h)>>8
000000E4                          M 	shift
000000E4                          M 	dw	0000h
000000E4                          M 	rept	narg
000000E4 0000                     M 	dc.b	(0000h)&$ff,(0000h)>>8
000000E6                          M 	shift
000000E6                            		zsample	dTimpani, 1Bh			; Kick sample
000000E6                          M 	dw	dtimpani
000000E6                          M 	rept	narg
000000E6 0000                     M 	dc.b	(dtimpani)&$ff,(dtimpani)>>8
000000E8                          M 	shift
000000E8                          M 	dw	dtimpani_end-dtimpani
000000E8                          M 	rept	narg
000000E8 0000                     M 	dc.b	(dtimpani_end-dtimpani)&$ff,(dtimpani_end-dtimpani)>>8
000000EA                          M 	shift
000000EA                          M 	dw	1bh
000000EA                          M 	rept	narg
000000EA 1B00                     M 	dc.b	(1bh)&$ff,(1bh)>>8
000000EC                          M 	shift
000000EC                          M 	dw	0000h
000000EC                          M 	rept	narg
000000EC 0000                     M 	dc.b	(0000h)&$ff,(0000h)>>8
000000EE                          M 	shift
000000EE =000000EA                  Sample3_Pitch	= *-4					; this is the location of timpani pitch
000000EE                            
000000EE                            ; ===========================================================================
000000EE                            ; ---------------------------------------------------------------------------
000000EE                            ; Includes for all the samples
000000EE                            ; ---------------------------------------------------------------------------
000000EE                            
000000EE                            dKick:		incbin "sound/dac/kick.dpcm"
00000440                            dKick_End:
00000440                            
00000440                            dSnare:		incbin "sound/dac/snare.dpcm"
00000BB0                            dSnare_End:
00000BB0                            
00000BB0                            dTimpani:	incbin "sound/dac/timpani.dpcm"
00001BC6                            dTimpani_End:
00001BC6                            ; ---------------------------------------------------------------------------
00001BC6                            
00001BC6                            EndOfDriver:
